#include "encryptor.h"
#include "crypto_interface.h" // Generated by cbindgen from Rust

#include <fstream>
#include <iostream>
#include <cstring>
#include <filesystem>

namespace crusty {

// Helper function to read a file into a vector
std::vector<uint8_t> Encryptor::readFile(const std::string& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file.is_open()) {
        throw EncryptionException("Failed to open file for reading: " + path);
    }
    
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<uint8_t> buffer(size);
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw EncryptionException("Failed to read file: " + path);
    }
    
    return buffer;
}

// Helper function to write a vector to a file
void Encryptor::writeFile(const std::string& path, const std::vector<uint8_t>& data) {
    // Create directory if it doesn't exist
    std::filesystem::path filePath(path);
    std::filesystem::create_directories(filePath.parent_path());
    
    std::ofstream file(path, std::ios::binary);
    if (!file.is_open()) {
        throw EncryptionException("Failed to open file for writing: " + path);
    }
    
    if (!file.write(reinterpret_cast<const char*>(data.data()), data.size())) {
        throw EncryptionException("Failed to write file: " + path);
    }
}

// Encrypt raw data with a password
std::vector<uint8_t> Encryptor::encryptData(
    const std::vector<uint8_t>& data,
    const std::string& password
) {
    // Prepare output buffer (data size + overhead for nonce and tag)
    std::vector<uint8_t> output(data.size() + 32);
    size_t output_len = 0;
    
    // Call Rust encryption function
    int32_t result = encrypt_data(
        data.data(), data.size(),
        reinterpret_cast<const uint8_t*>(password.c_str()), password.size(),
        output.data(), output.size(),
        &output_len
    );
    
    // Handle errors
    if (result != 0) {
        std::string error_message;
        switch (result) {
            case -1: error_message = "Invalid parameters"; break;
            case -2: error_message = "Authentication failed"; break;
            case -3: error_message = "Encryption error"; break;
            case -4: error_message = "Decryption error"; break;
            case -5: error_message = "Key derivation error"; break;
            case -6: 
                // Buffer too small, resize and try again
                output.resize(output_len);
                return encryptData(data, password);
            case -7: error_message = "Internal error"; break;
            default: error_message = "Unknown error"; break;
        }
        throw EncryptionException("Failed to encrypt data: " + error_message);
    }
    
    // Resize output to actual length
    output.resize(output_len);
    
    return output;
}

// Decrypt raw data with a password
std::vector<uint8_t> Encryptor::decryptData(
    const std::vector<uint8_t>& data,
    const std::string& password
) {
    // Prepare output buffer (data size is an upper bound for plaintext size)
    std::vector<uint8_t> output(data.size());
    size_t output_len = 0;
    
    // Call Rust decryption function
    int32_t result = decrypt_data(
        data.data(), data.size(),
        reinterpret_cast<const uint8_t*>(password.c_str()), password.size(),
        output.data(), output.size(),
        &output_len
    );
    
    // Handle errors
    if (result != 0) {
        std::string error_message;
        switch (result) {
            case -1: error_message = "Invalid parameters"; break;
            case -2: error_message = "Authentication failed (wrong password)"; break;
            case -3: error_message = "Encryption error"; break;
            case -4: error_message = "Decryption error"; break;
            case -5: error_message = "Key derivation error"; break;
            case -6: 
                // Buffer too small, resize and try again
                output.resize(output_len);
                return decryptData(data, password);
            case -7: error_message = "Internal error"; break;
            default: error_message = "Unknown error"; break;
        }
        throw EncryptionException("Failed to decrypt data: " + error_message);
    }
    
    // Resize output to actual length
    output.resize(output_len);
    
    return output;
}

// Encrypt a file with a password
void Encryptor::encryptFile(
    const std::string& sourcePath,
    const std::string& destPath,
    const std::string& password,
    std::function<void(float)> progressCallback
) {
    // Check if destination file already exists
    if (std::filesystem::exists(destPath)) {
        throw EncryptionException("Destination file already exists: " + destPath);
    }
    
    // Update progress
    if (progressCallback) {
        progressCallback(0.0f);
    }
    
    // Read source file
    std::vector<uint8_t> data = readFile(sourcePath);
    
    // Update progress
    if (progressCallback) {
        progressCallback(0.3f);
    }
    
    // Encrypt data
    std::vector<uint8_t> encrypted = encryptData(data, password);
    
    // Update progress
    if (progressCallback) {
        progressCallback(0.7f);
    }
    
    // Write encrypted data to destination file
    writeFile(destPath, encrypted);
    
    // Update progress
    if (progressCallback) {
        progressCallback(1.0f);
    }
}

// Decrypt a file with a password
void Encryptor::decryptFile(
    const std::string& sourcePath,
    const std::string& destPath,
    const std::string& password,
    const std::string& secondFactor,
    std::function<void(float)> progressCallback
) {
    // Check if destination file already exists
    if (std::filesystem::exists(destPath)) {
        throw EncryptionException("Destination file already exists: " + destPath);
    }
    
    // Update progress
    if (progressCallback) {
        progressCallback(0.0f);
    }
    
    // Read source file
    std::vector<uint8_t> data = readFile(sourcePath);
    
    // Update progress
    if (progressCallback) {
        progressCallback(0.3f);
    }
    
    // If second factor is provided, verify it
    // Note: This is a placeholder for 2FA implementation
    if (!secondFactor.empty()) {
        // TODO: Implement 2FA verification
        // For now, we just ignore the second factor
    }
    
    // Decrypt data
    std::vector<uint8_t> decrypted = decryptData(data, password);
    
    // Update progress
    if (progressCallback) {
        progressCallback(0.7f);
    }
    
    // Write decrypted data to destination file
    writeFile(destPath, decrypted);
    
    // Update progress
    if (progressCallback) {
        progressCallback(1.0f);
    }
}

// Hash a password for verification
std::string Encryptor::hashPassword(const std::string& password) {
    // Prepare output buffer
    std::vector<uint8_t> output(256);
    
    // Call Rust hash function
    int32_t result = hash_password(
        reinterpret_cast<const uint8_t*>(password.c_str()), password.size(),
        output.data(), output.size()
    );
    
    // Handle errors
    if (result != 0) {
        throw EncryptionException("Failed to hash password");
    }
    
    // Convert to string (output is null-terminated)
    return std::string(reinterpret_cast<char*>(output.data()));
}

// Verify a password against a hash
bool Encryptor::verifyPassword(const std::string& password, const std::string& hash) {
    // TODO: Implement password verification
    // For now, we just return true if the password is not empty
    return !password.empty();
}

} // namespace crusty
