#include "encryptor.h"
#include "secure_utils.h"
#include "audit_log.h"
#include "path_utils.h"
#include "crypto_interface.h" // Generated by cbindgen from Rust

#include <fstream>
#include <iostream>
#include <cstring>
#include <filesystem>
#include <algorithm>

namespace crusty {

// Define Rust crypto error codes directly when Qt is not available
#ifdef NO_QT_UI
namespace crypto {
    enum class CryptoErrorCode {
        Success = 0,
        InvalidParams = -1,
        AuthenticationFailed = -2,
        EncryptionError = -3,
        DecryptionError = -4,
        KeyDerivationError = -5,
        BufferTooSmall = -6,
        InternalError = -7
    };
}
#endif

namespace {

// Map from Rust crypto error codes to our C++ error codes
CryptoErrorCode mapErrorCode(int32_t rustErrorCode) {
    switch (rustErrorCode) {
        case -1: // InvalidParams
            return CryptoErrorCode::InvalidPassword;
        case -2: // AuthenticationFailed
            return CryptoErrorCode::AuthenticationFailed;
        case -3: // EncryptionError
        case -4: // DecryptionError
            return CryptoErrorCode::DataCorrupted;
        case -5: // KeyDerivationError
            return CryptoErrorCode::InvalidPassword;
        default:
            return CryptoErrorCode::InternalError;
    }
}

std::string getErrorMessage(int32_t errorCode) {
    switch (errorCode) {
        case -1: // InvalidParams
            return "Invalid parameters";
        case -2: // AuthenticationFailed
            return "Authentication failed (wrong password)";
        case -3: // EncryptionError
            return "Encryption error";
        case -4: // DecryptionError
            return "Decryption error";
        case -5: // KeyDerivationError
            return "Key derivation error";
        case -6: // BufferTooSmall
            return "Buffer too small";
        case -7: // InternalError
            return "Internal error";
        default:
            return "Unknown error";
    }
}

void updateProgress(const ProgressCallback& progressCallback, float progress) {
    if (progressCallback) {
        progressCallback(progress);
    }
}

}  // anonymous namespace

//
// Crypto implementation
//

std::vector<uint8_t> Crypto::encrypt(
    const std::vector<uint8_t>& plaintext,
    const std::string& password
) const {
    LOG_SECURITY("Encrypting data (" + std::to_string(plaintext.size()) + " bytes)");
    
    // Create a secure copy of the password
    secure::SecureData<std::string> securePassword(password);
    
    // Data size + overhead for nonce and tag
    std::vector<uint8_t> output(plaintext.size() + 32);
    size_t output_len = 0;
    
    int32_t result = encrypt_data(
        plaintext.data(), plaintext.size(),
        reinterpret_cast<const uint8_t*>(securePassword.get().c_str()), 
        securePassword.get().size(),
        output.data(), output.size(),
        &output_len
    );
    
    if (result != 0) {
        if (result == -6) { // BufferTooSmall
            output.resize(output_len);
            return encrypt(plaintext, password);
        }
        
        std::string errorMsg = "Failed to encrypt data: " + getErrorMessage(result);
        LOG_ERROR(errorMsg);
        throw EncryptionException(errorMsg, mapErrorCode(result));
    }
    
    output.resize(output_len);
    LOG_SECURITY("Data encrypted successfully (" + std::to_string(output.size()) + " bytes)");
    return output;
}

std::vector<uint8_t> Crypto::decrypt(
    const std::vector<uint8_t>& ciphertext,
    const std::string& password
) const {
    LOG_SECURITY("Decrypting data (" + std::to_string(ciphertext.size()) + " bytes)");
    
    // Create a secure copy of the password
    secure::SecureData<std::string> securePassword(password);
    
    std::vector<uint8_t> output(ciphertext.size());
    size_t output_len = 0;
    
    int32_t result = decrypt_data(
        ciphertext.data(), ciphertext.size(),
        reinterpret_cast<const uint8_t*>(securePassword.get().c_str()), 
        securePassword.get().size(),
        output.data(), output.size(),
        &output_len
    );
    
    if (result != 0) {
        if (result == -6) { // BufferTooSmall
            output.resize(output_len);
            return decrypt(ciphertext, password);
        }
        
        std::string errorMsg = "Failed to decrypt data: " + getErrorMessage(result);
        LOG_ERROR(errorMsg);
        throw EncryptionException(errorMsg, mapErrorCode(result));
    }
    
    output.resize(output_len);
    LOG_SECURITY("Data decrypted successfully (" + std::to_string(output.size()) + " bytes)");
    return output;
}

std::string Crypto::hashPassword(const std::string& password) const {
    LOG_SECURITY("Hashing password");
    
    // Create a secure copy of the password
    secure::SecureData<std::string> securePassword(password);
    
    constexpr size_t HASH_BUFFER_SIZE = 256;
    std::vector<uint8_t> output(HASH_BUFFER_SIZE);
    
    int32_t result = hash_password(
        reinterpret_cast<const uint8_t*>(securePassword.get().c_str()), 
        securePassword.get().size(),
        output.data(), 
        output.size()
    );
    
    if (result != 0) {
        std::string errorMsg = "Failed to hash password: " + getErrorMessage(result);
        LOG_ERROR(errorMsg);
        throw EncryptionException(errorMsg, mapErrorCode(result));
    }
    
    LOG_SECURITY("Password hashed successfully");
    return std::string(reinterpret_cast<char*>(output.data()));
}

bool Crypto::verifyPassword(
    const std::string& password, 
    const std::string& hash
) const {
    LOG_SECURITY("Verifying password");
    
    if (password.empty() || hash.empty()) {
        LOG_WARNING("Empty password or hash provided for verification");
        return false;
    }
    
    // In a real implementation, we would use Argon2id to verify the password
    // against the stored hash. For now, we'll implement a basic verification
    // that checks if the hash starts with the password (which is not secure,
    // but serves as a placeholder).
    
    // Create a new hash with the provided password
    std::string newHash;
    try {
        newHash = hashPassword(password);
    } catch (const EncryptionException& e) {
        LOG_ERROR("Failed to hash password for verification: " + std::string(e.what()));
        return false;
    }
    
    // Compare the first few characters of the hashes
    // This is NOT secure and is just a placeholder
    bool result = (hash.substr(0, 16) == newHash.substr(0, 16));
    
    if (result) {
        LOG_SECURITY("Password verified successfully");
    } else {
        LOG_SECURITY("Password verification failed");
    }
    
    return result;
}

//
// Encryptor implementation
//

Encryptor::Encryptor() 
    : crypto_(std::make_unique<Crypto>()) {
}

Encryptor::Encryptor(std::unique_ptr<Crypto> crypto) 
    : crypto_(std::move(crypto)) {
}

void Encryptor::encryptFile(
    const std::string& sourcePath,
    const std::string& destPath,
    const std::string& password,
    ProgressCallback progressCallback
) {
    try {
        // Sanitize paths
        std::string sanitizedSourcePath = PathUtils::sanitizePath(sourcePath);
        std::string sanitizedDestPath = PathUtils::sanitizePath(destPath);
        
        LOG_SECURITY("Encrypting file: " + sanitizedSourcePath + " -> " + sanitizedDestPath);
        
        // Check if source file exists
        if (!std::filesystem::exists(sanitizedSourcePath)) {
            std::string errorMsg = "Source file does not exist: " + sanitizedSourcePath;
            LOG_ERROR(errorMsg);
            throw EncryptionException(errorMsg, CryptoErrorCode::IoError);
        }
        
        // Check if destination file already exists
        if (std::filesystem::exists(sanitizedDestPath)) {
            std::string errorMsg = "Destination file already exists: " + sanitizedDestPath;
            LOG_ERROR(errorMsg);
            throw EncryptionException(errorMsg, CryptoErrorCode::IoError);
        }
        
        // Process the file in chunks to handle large files
        processFileInChunks(sanitizedSourcePath, sanitizedDestPath, password, true, progressCallback);
        
        LOG_SECURITY("File encrypted successfully");
    } catch (const std::exception& e) {
        std::string errorMsg = "Failed to encrypt file: " + std::string(e.what());
        LOG_ERROR(errorMsg);
        throw EncryptionException(errorMsg, CryptoErrorCode::IoError);
    }
}

void Encryptor::decryptFile(
    const std::string& sourcePath,
    const std::string& destPath,
    const std::string& password,
    ProgressCallback progressCallback
) {
    try {
        // Sanitize paths
        std::string sanitizedSourcePath = PathUtils::sanitizePath(sourcePath);
        std::string sanitizedDestPath = PathUtils::sanitizePath(destPath);
        
        LOG_SECURITY("Decrypting file: " + sanitizedSourcePath + " -> " + sanitizedDestPath);
        
        // Check if source file exists
        if (!std::filesystem::exists(sanitizedSourcePath)) {
            std::string errorMsg = "Source file does not exist: " + sanitizedSourcePath;
            LOG_ERROR(errorMsg);
            throw EncryptionException(errorMsg, CryptoErrorCode::IoError);
        }
        
        // Check if destination file already exists
        if (std::filesystem::exists(sanitizedDestPath)) {
            std::string errorMsg = "Destination file already exists: " + sanitizedDestPath;
            LOG_ERROR(errorMsg);
            throw EncryptionException(errorMsg, CryptoErrorCode::IoError);
        }
        
        // Process the file in chunks to handle large files
        processFileInChunks(sanitizedSourcePath, sanitizedDestPath, password, false, progressCallback);
        
        LOG_SECURITY("File decrypted successfully");
    } catch (const std::exception& e) {
        std::string errorMsg = "Failed to decrypt file: " + std::string(e.what());
        LOG_ERROR(errorMsg);
        throw EncryptionException(errorMsg, CryptoErrorCode::IoError);
    }
}

void Encryptor::setChunkSize(size_t bytes) {
    if (bytes == 0) {
        LOG_WARNING("Attempted to set chunk size to 0, ignoring");
        return;
    }
    
    chunk_size_ = bytes;
    LOG_INFO("Chunk size set to " + std::to_string(chunk_size_) + " bytes");
}

std::vector<uint8_t> Encryptor::readFileChunk(std::istream& file, size_t size) {
    std::vector<uint8_t> buffer(size);
    file.read(reinterpret_cast<char*>(buffer.data()), size);
    
    // Resize buffer to actual bytes read
    size_t bytesRead = file.gcount();
    buffer.resize(bytesRead);
    
    return buffer;
}

void Encryptor::writeFileChunk(std::ostream& file, const std::vector<uint8_t>& data) {
    if (!file.write(reinterpret_cast<const char*>(data.data()), data.size())) {
        throw EncryptionException("Failed to write to file", CryptoErrorCode::IoError);
    }
}

void Encryptor::processFileInChunks(
    const std::string& sourcePath,
    const std::string& destPath,
    const std::string& password,
    bool encrypting,
    ProgressCallback progressCallback
) {
    // Create a secure copy of the password
    secure::SecureData<std::string> securePassword(password);
    
    // Open source file
    std::ifstream sourceFile(sourcePath, std::ios::binary);
    if (!sourceFile.is_open()) {
        throw EncryptionException("Failed to open source file: " + sourcePath, CryptoErrorCode::IoError);
    }
    
    // Get file size for progress reporting
    sourceFile.seekg(0, std::ios::end);
    std::streamsize fileSize = sourceFile.tellg();
    sourceFile.seekg(0, std::ios::beg);
    
    // Create parent directories for destination file if needed
    std::filesystem::path destFilePath(destPath);
    std::filesystem::create_directories(destFilePath.parent_path());
    
    // Open destination file
    std::ofstream destFile(destPath, std::ios::binary);
    if (!destFile.is_open()) {
        throw EncryptionException("Failed to open destination file: " + destPath, CryptoErrorCode::IoError);
    }
    
    // Process file in chunks
    std::streamsize processedBytes = 0;
    while (sourceFile && !sourceFile.eof()) {
        // Read a chunk
        std::vector<uint8_t> chunk = readFileChunk(sourceFile, chunk_size_);
        if (chunk.empty()) {
            break;
        }
        
        // Process the chunk
        std::vector<uint8_t> processedChunk;
        if (encrypting) {
            processedChunk = crypto_->encrypt(chunk, securePassword.get());
        } else {
            processedChunk = crypto_->decrypt(chunk, securePassword.get());
        }
        
        // Write the processed chunk
        writeFileChunk(destFile, processedChunk);
        
        // Update progress
        processedBytes += chunk.size();
        float progress = static_cast<float>(processedBytes) / static_cast<float>(fileSize);
        updateProgress(progressCallback, progress);
        
        // Securely wipe the chunks from memory
        secure::wipe(chunk);
        secure::wipe(processedChunk);
    }
    
    // Ensure all data is written
    destFile.flush();
    
    // Close files
    sourceFile.close();
    destFile.close();
}

} // namespace crusty
