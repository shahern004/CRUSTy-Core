# CRUSTy-Core Developer Setup Guide

This guide provides instructions for setting up a development environment for CRUSTy-Core, a secure file encryption application with a hybrid C++/Rust architecture.

## Prerequisites

Before you begin, ensure you have the following installed:

### Required Tools

- **Git**: For version control
- **CMake** (3.15 or higher): For build configuration
- **C++ Compiler**:
  - Windows: Visual Studio 2019 or newer with C++ workload
  - macOS: Xcode Command Line Tools or Clang
  - Linux: GCC 9+ or Clang 10+
- **Rust** (1.56 or higher): For cryptographic components
  - Install using [rustup](https://rustup.rs/)

### Optional Tools

- **Visual Studio Code**: Recommended IDE with the following extensions:
  - C/C++ extension
  - Rust-analyzer
  - CMake Tools
- **Doxygen**: For generating documentation

## Setting Up the Development Environment

### 1. Clone the Repository

```bash
git clone https://github.com/yourusername/CRUSTy-Core.git
cd CRUSTy-Core
```

### 2. Install Rust Dependencies

```bash
# Navigate to the Rust crypto library
cd rust/crypto

# Install required Rust components
rustup component add rustfmt clippy

# Check that everything compiles
cargo check
```

### 3. Configure CMake

```bash
# Return to the project root
cd ../..

# Create a build directory
mkdir build
cd build

# Configure CMake
# Replace Qt6_DIR with your Qt installation path if needed
cmake .. -DQt6_DIR=/path/to/qt/lib/cmake/Qt6
```

### 4. Build the Project

```bash
# Build the project
cmake --build . --config Release
```

### 5. Run the Application

```bash
# Run the application from the build directory
./crusty_qt  # On Linux/macOS
.\Release\crusty_qt.exe  # On Windows
```

## Project Structure

The CRUSTy-Core project follows a hybrid C++/Rust architecture:

```
CRUSTy-Core/
├── CMakeLists.txt           # Main CMake configuration
├── Documentation/           # Documentation files
├── rust/                    # Rust components
│   └── crypto/              # Rust cryptographic library
│       ├── Cargo.toml       # Rust dependencies
│       ├── build.rs         # Rust build script
│       ├── cbindgen.toml    # cbindgen configuration
│       └── src/             # Rust source code
│           └── lib.rs       # Main Rust library
└── src/                     # C++ components
    └── cpp/                 # C++ source code
        ├── main.cpp         # Application entry point
        ├── core/            # Core C++ components
        │   ├── crypto_interface.h  # FFI interface to Rust
        │   ├── encryptor.cpp       # Encryption wrapper
        │   ├── encryptor.h         # Encryption interface
        │   ├── file_operations.cpp # File handling
        │   └── file_operations.h   # File operations interface
        └── ui/              # Qt UI components
            ├── main_window.cpp     # Main window implementation
            └── main_window.h       # Main window interface
```

## Development Workflow

### Building and Testing

1. **Incremental Builds**: After making changes, rebuild the project:

   ```bash
   cd build
   cmake --build .
   ```

2. **Running Tests**:
   - For Rust components:
     ```bash
     cd rust/crypto
     cargo test
     ```
   - For C++ components (once tests are implemented):
     ```bash
     cd build
     ctest
     ```

### Code Style and Linting

- **C++ Code**: Follow the project's C++ style guide (based on Google C++ Style Guide)

  - Use `clang-format` with the provided `.clang-format` file

- **Rust Code**: Follow Rust's official style guidelines
  - Use `cargo fmt` to format code
  - Use `cargo clippy` for linting

### Debugging

1. **Debugging the Application**:

   - Use Visual Studio Code's debugger with the C/C++ extension
   - Use GDB or LLDB from the command line
   - Use Qt Creator's debugger for UI components

2. **Debugging Rust Components**:
   - Use `rust-gdb` or `rust-lldb` for Rust-specific debugging
   - Add `println!` statements for quick debugging

## Working with the FFI Boundary

The interface between C++ and Rust is defined in `src/cpp/core/crypto_interface.h` and generated by cbindgen from the Rust code.

When modifying the Rust cryptographic functions:

1. Ensure functions intended for C++ use are marked with `#[no_mangle]` and `pub extern "C"`
2. Update the cbindgen configuration in `rust/crypto/cbindgen.toml` if needed
3. Rebuild the project to regenerate the C header file

## Embedded Development

For STM32H573I-DK embedded development:

### Required Tools for Embedded Development

1. **CMake** (4.0 or higher):

   - Download from [CMake's website](https://cmake.org/download/)
   - Select the Windows x64 Installer (cmake-x.x.x-windows-x86_64.msi)
   - During installation, select "Add CMake to the system PATH for all users"

2. **ARM GNU Toolchain**:

   - Download from [ARM's website](https://developer.arm.com/downloads/-/gnu-rm)
   - Select the Windows AArch32 bare-metal target (arm-none-eabi) installer
   - During installation, check "Add path to environment variable"

3. **MSYS2 and MinGW**:

   - Download from [MSYS2's website](https://www.msys2.org/)
   - Run the installer and use the default installation location (C:\msys64)
   - After installation, open the MSYS2 terminal and run:
     ```
     pacman -Syu
     ```
   - After the terminal closes, reopen it and run:
     ```
     pacman -Syu
     pacman -S --needed base-devel mingw-w64-x86_64-toolchain
     ```

4. **Ninja Build System**:

   - In the MSYS2 terminal, run:
     ```
     pacman -S mingw-w64-x86_64-ninja
     ```

5. **Add to PATH**:

   - Add MinGW and Ninja to your system PATH:
     - Open Windows Settings
     - Search for "Environment Variables"
     - Edit the system environment variables
     - Add `C:\msys64\mingw64\bin` to the PATH

6. **STM32CubeProgrammer**:

   - Download from [ST's website](https://www.st.com/en/development-tools/stm32cubeprog.html)
   - Install with default options

### Building for STM32H573I-DK

1. Configure CMake for embedded target:

   ```bash
   cmake -S . -B build -DBUILD_EMBEDDED_TARGET=ON -DCMAKE_TOOLCHAIN_FILE=cmake/arm-none-eabi.cmake -G "Ninja"
   ```

2. Build the embedded firmware:

   ```bash
   cmake --build build --target crusty_embedded
   ```

3. The output ELF file will be in the build directory, along with a .bin file for flashing

4. Flash the firmware using STM32CubeProgrammer:
   ```bash
   STM32_Programmer_CLI -c port=SWD -w build/crusty_embedded.bin 0x08000000 -v -rst
   ```

### Verifying the ARM Toolchain

To verify that the ARM toolchain is correctly configured:

1. Create a simple test project:

   ```bash
   mkdir arm_test && cd arm_test
   ```

2. Create a basic main.cpp file with LED blinking functionality

3. Configure and build with CMake:

   ```bash
   cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=../cmake/arm-none-eabi.cmake -G "Ninja"
   cmake --build build
   ```

4. Verify the output is an ELF file suitable for ARM Cortex-M7:
   ```bash
   arm-none-eabi-readelf -h build/arm_test
   ```

## QEMU Emulation

For development and testing without physical hardware, you can use QEMU to emulate the STM32H573I-DK. See the [QEMU Guide](Embedded/QEMU_GUIDE.md) for detailed instructions on setting up and using QEMU for STM32H573I-DK emulation.

## Submitting Changes

1. Create a new branch for your feature or bugfix:

   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes and commit them with clear, descriptive commit messages

3. Push your branch to GitHub:

   ```bash
   git push origin feature/your-feature-name
   ```

4. Create a Pull Request on GitHub

5. Ensure all CI checks pass

6. Wait for code review and address any feedback

## Getting Help

If you encounter issues during development:

1. Check the existing GitHub Issues for similar problems
2. Join the developer discussion on [Discord/Slack/etc.]
3. Ask questions in the Pull Request if related to a specific change
